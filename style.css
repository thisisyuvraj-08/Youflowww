// FIREBASE SDKs - Imported from index.html
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-analytics.js";

// ============ Minimalist Animated Intro Logic ============
function playMinimalistIntro() {
    const overlay = document.getElementById('introOverlay');
    const sparkle = overlay ? overlay.querySelector('.sparkle') : null;
    if (sparkle) {
        for (let i = 0; i < 12; i++) {
            const dot = document.createElement('div');
            dot.className = 'sparkle-dot';
            dot.style.left = `${60 + Math.random()*90}px`;
            dot.style.top = `${80 + Math.random()*60}px`;
            dot.style.animationDelay = `${Math.random()*2.2}s`;
            dot.style.background = `linear-gradient(135deg,#f7a047 0%,#6c63ff 100%)`;
            sparkle.appendChild(dot);
        }
        setTimeout(() => {
            overlay.classList.add('fade-out');
            setTimeout(() => { overlay.style.display = 'none'; }, 1200);
        }, 3400);
    }
}
window.addEventListener('DOMContentLoaded', playMinimalistIntro);

// ============ NEW: Guest Mode State ============
let isGuestMode = false;

// ============ NEW: Guest Mode Handler ============
document.addEventListener('DOMContentLoaded', () => {
    const guestBtn = document.getElementById("continueWithoutSignupBtn");
    const guestWarning = document.getElementById("guestWarning");
    if (guestBtn) {
        guestBtn.addEventListener('click', () => {
            isGuestMode = true;
            DOMElements.appContainer.classList.remove('hidden');
            DOMElements.authModal.classList.remove('visible');
            guestWarning.classList.remove('hidden');
            currentUserData = loadGuestData() || getDefaultUserData();
            initializeAppState();
        });
    }
});

function getDefaultUserData() {
    return {
        profileName: "Floww User",
        totalFocusMinutes: 0,
        totalSessions: 0,
        streakCount: 0,
        lastStreakDate: null,
        weeklyFocus: {},
        todos: [],
        settings: {
            workDuration: 25 * 60,
            shortBreakDuration: 5 * 60,
            longBreakDuration: 15 * 60,
            soundProfile: "indian",
            isAccountabilityOn: false,
            isSleepDetectionOn: false,
        },
        theme: { backgroundPath: null, youtubeVideoId: null }
    };
}

// ===================================================================================
// FIREBASE INITIALIZATION
// ===================================================================================
const firebaseConfig = {
    apiKey: "AIzaSyBCi5Ea0r2c9tdgk_6RnpSuqDV5CE3nGbo",
    authDomain: "youfloww2.firebaseapp.com",
    projectId: "youfloww2",
    storageBucket: "youfloww2.firbasestorage.app",
    messagingSenderId: "816836186464",
    appId: "1:816836186464:web:e1f816020e6798f9b3ce05",
    measurementId: "G-TBY81E0BC4"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const analytics = getAnalytics(app);
let currentUserData = {};
let userDataRef = null;

// ===================================================================================
// GLOBAL STATE & VARIABLES
// ===================================================================================
let timerInterval, isRunning = false, isWorkSession = true, sessionCount = 0;
let endTime = 0, timeLeft;
let workDuration, shortBreakDuration, longBreakDuration;
let sessionStartTime = null;
let totalAwayTime = 0;
let lastPauseTimestamp = null;
let pauseWasManual = true;
let animationFrameId = null;
let isSnowActive = false, isRainActive = false, isSakuraActive = false;
let lastSnowSpawn = 0, lastRainSpawn = 0, lastSakuraSpawn = 0;
const SNOW_INTERVAL = 200, RAIN_INTERVAL = 50, SAKURA_INTERVAL = 500;

// ACCOUNTABILITY AI STATE - replaced with MediaPipe FaceMesh implementation
let isAccountabilityOn = false;
window.isAccountabilityOn = isAccountabilityOn; // Debug global
let isSleepDetectionOn = false;
window.isSleepDetectionOn = isSleepDetectionOn; // Debug global

let awayTimerStart = null;
let eyesClosedTimerStart = null;
let camera = null;             // MediaPipe Camera instance
let faceMesh = null;           // MediaPipe FaceMesh instance
let lastFaceDetected = false;
let lastEAR = 1.0;
let faceDetectionRunning = false;

// ===================================================================================
// DOM ELEMENTS CACHE
// ===================================================================================
const DOMElements = {
    video: document.getElementById("video"),
    timerDisplay: document.getElementById("timer"),
    statusDisplay: document.getElementById("status"),
    playPauseBtn: document.getElementById("playPauseBtn"),
    playIcon: document.getElementById("playIcon"),
    pauseIcon: document.getElementById("pauseIcon"),
    resetBtn: document.getElementById("resetBtn"),
    endSessionBtn: document.getElementById("endSessionBtn"),
    appContainer: document.getElementById("app-container"),
    authModal: document.getElementById("authModal"),
    authError: document.getElementById("auth-error"),
    ambientContainer: document.getElementById("ambient-container"),
    faceStatusPrompt: document.getElementById('face-detection-status'),
    focusMode: {
        ui: document.getElementById("focusModeUI"),
        timer: document.getElementById("focusModeTimer"),
        progressBar: document.getElementById("focusModeProgressBar"),
        playPauseBtn: document.getElementById("focusModePlayPauseBtn"),
        exitBtn: document.getElementById("focusModeExitBtn"),
    },
    modals: {
        stats: document.getElementById("statsModal"),
        completion: document.getElementById("completionModal"),
        review: document.getElementById("reviewModal"),
        totalFocusTime: document.getElementById("totalFocusTime"),
        totalSessionsCount: document.getElementById("totalSessionsCount"),
    },
    profile: {
        nameDisplay: document.getElementById("profileNameDisplay"),
    },
    streak: {
        count: document.getElementById("streak-count"),
    },
    settings: {
        soundEffects: document.getElementById('sound-effects-select'),
        accountabilityToggle: document.getElementById('accountability-toggle'),
        sleepDetectionToggle: document.getElementById('sleep-detection-toggle'),
    },
    sounds: {
        whiteNoise: document.getElementById("whiteNoise"),
        // Note: pauseAlertSound/resumeAlertSound elements may or may not exist in HTML; keep them optional
        pauseAlert: document.getElementById("pauseAlertSound"),
        resumeAlert: document.getElementById("resumeAlertSound"),
        indian: {
            start: document.querySelectorAll('.start-sound-indian'),
            good: document.querySelectorAll('.good-meme-indian'),
            bad: document.querySelectorAll('.bad-meme-indian'),
        },
        nonIndian: {
            start: document.querySelectorAll('.start-sound-non-indian'),
            good: document.querySelectorAll('.good-meme-non-indian'),
            bad: document.querySelectorAll('.bad-meme-non-indian'),
        }
    }
};

// ===================================================================================
// FIREBASE AUTH & DATA
// ===================================================================================
onAuthStateChanged(auth, user => {
    if (user) {
        isGuestMode = false;
        DOMElements.appContainer.classList.remove('hidden');
        DOMElements.authModal.classList.remove('visible');
        userDataRef = doc(db, "users", user.uid);
        loadUserData();
    } else if (!isGuestMode) {
        DOMElements.appContainer.classList.add('hidden');
        DOMElements.authModal.classList.add('visible');
        if (timerInterval) clearInterval(timerInterval);
        isRunning = false;
    }
});

function saveUserData() {
    if (isGuestMode) {
        localStorage.setItem('youfloww_guest', JSON.stringify(currentUserData));
    } else if (userDataRef) {
        setDoc(userDataRef, currentUserData, { merge: true }).catch(error => console.error("Error saving user data: ", error));
    }
}
function loadUserData() {
    if (isGuestMode) {
        currentUserData = loadGuestData() || getDefaultUserData();
        initializeAppState();
    } else if (userDataRef) {
        getDoc(userDataRef).then(docSnap => {
            if (docSnap.exists()) {
                currentUserData = docSnap.data();
            }
            initializeAppState();
        });
    }
}
function loadGuestData() {
    try { return JSON.parse(localStorage.getItem('youfloww_guest')); } catch { return null; }
}

// ===================================================================================
// CORE TIMER LOGIC
// ===================================================================================
function updateTimerDisplay() {
    const minutes = Math.floor(timeLeft / 60);
    const seconds = timeLeft % 60;
    const timeString = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    DOMElements.timerDisplay.textContent = timeString;
    DOMElements.focusMode.timer.textContent = timeString;
    const currentDuration = isWorkSession ? workDuration : (sessionCount % 4 === 0 ? longBreakDuration : shortBreakDuration);
    const progress = timeLeft > 0 ? ((currentDuration - timeLeft) / currentDuration) * 100 : 0;
    DOMElements.focusMode.progressBar.style.width = `${progress}%`;
    document.title = isRunning ? `${timeString} - ${isWorkSession ? 'Work' : 'Break'} | YouFloww` : 'YouFloww';
}

function updateUIState() {
    DOMElements.statusDisplay.textContent = isWorkSession ? "Work Session" : "Break Time";
    DOMElements.playIcon.classList.toggle('hidden', isRunning);
    DOMElements.pauseIcon.classList.toggle('hidden', !isRunning);
    DOMElements.playPauseBtn.setAttribute('aria-label', isRunning ? 'Pause Timer' : 'Start Timer');
    DOMElements.resetBtn.disabled = isRunning;
    DOMElements.endSessionBtn.disabled = !isRunning;
    DOMElements.focusMode.playPauseBtn.classList.toggle('paused', !isRunning);
}

function playRandomSound(type) {
    const soundProfile = currentUserData.settings?.soundProfile;
    if (soundProfile === 'off') return;
    let soundSet = (soundProfile === 'indian') ? DOMElements.sounds.indian[type] : DOMElements.sounds.nonIndian[type];
    if (soundSet && soundSet.length > 0) {
        const sound = soundSet[Math.floor(Math.random() * soundSet.length)];
        sound.currentTime = 0;
        sound.play().catch(e => console.error("Audio play failed:", e));
    }
}

function startTimer(isResume = false) {
    if (isRunning) return;
    isRunning = true;
    if (isWorkSession) {
        if (isResume) DOMElements.sounds.resumeAlert && DOMElements.sounds.resumeAlert.play();
        else playRandomSound('start');
    }
    if (!sessionStartTime) sessionStartTime = Date.now();
    if (lastPauseTimestamp) {
        totalAwayTime += Date.now() - lastPauseTimestamp;
        lastPauseTimestamp = null;
    }
    endTime = Date.now() + timeLeft * 1000;
    updateUIState();
    if (isAccountabilityOn || isSleepDetectionOn) {
        startFaceDetection();
    }
    timerInterval = setInterval(() => {
        timeLeft = Math.round((endTime - Date.now()) / 1000);
        if (timeLeft <= 0) {
            clearInterval(timerInterval);
            timeLeft = 0;
            updateTimerDisplay();
            isRunning = false;
            handleSessionCompletion();
        } else {
            updateTimerDisplay();
        }
    }, 1000);

    if ((isAccountabilityOn || isSleepDetectionOn) && !DOMElements.video.srcObject) {
        startVideo();
    }
}

function pauseTimer(isAuto = false) {
    if (!isRunning) return;
    clearInterval(timerInterval);
    isRunning = false;
    if (!isAuto) {
        pauseWasManual = true;
        DOMElements.sounds.pauseAlert && DOMElements.sounds.pauseAlert.play();
        stopFaceDetection();
    } else {
        pauseWasManual = false;
    }
    lastPauseTimestamp = Date.now();
    updateUIState();
}

function resetTimer() {
    clearInterval(timerInterval);
    stopFaceDetection();
    isRunning = false;
    isWorkSession = true;
    sessionCount = 0;
    timeLeft = workDuration;
    sessionStartTime = null;
    totalAwayTime = 0;
    updateTimerDisplay();
    updateUIState();
}

function endSession() {
    const timeFocusedSec = workDuration - timeLeft;
    const minutesFocused = Math.floor(timeFocusedSec / 60);
    handleEndOfWorkSession(minutesFocused, false);
    showSessionReview();
    resetTimer();
}

function handleSessionCompletion() {
    const minutesFocused = Math.floor(workDuration / 60);
    handleEndOfWorkSession(minutesFocused, true);
    showCompletionPopup();
    if (isAccountabilityOn || isSleepDetectionOn) showSessionReview();
    sessionCount++;
    isWorkSession = false;
    timeLeft = (sessionCount % 4 === 0) ? longBreakDuration : shortBreakDuration;
    sessionStartTime = null;
    totalAwayTime = 0;
    updateTimerDisplay();
    updateUIState();
    startTimer();
}

function handleEndOfWorkSession(minutesFocused, sessionCompleted) {
    stopFaceDetection();
    stopVideo();
    if (minutesFocused > 0) {
        currentUserData.totalFocusMinutes = (currentUserData.totalFocusMinutes || 0) + minutesFocused;
        currentUserData.totalSessions = (currentUserData.totalSessions || 0) + 1;
        const today = new Date().toISOString().slice(0, 10);
        if (!currentUserData.weeklyFocus) currentUserData.weeklyFocus = {};
        currentUserData.weeklyFocus[today] = (currentUserData.weeklyFocus[today] || 0) + minutesFocused;
    }
    if (minutesFocused >= 20) playRandomSound('good');
    else if (minutesFocused > 0) playRandomSound('bad');
    saveUserData();
}

// ===================================================================================
// ACCOUNTABILITY / SLEEP DETECTION (MediaPipe FaceMesh)
// ===================================================================================

/*
  Approach:
  - Use MediaPipe FaceMesh for fast face detection and landmarks.
  - Compute Eye Aspect Ratio (EAR) from selected eye landmarks.
  - Logic:
      * If no face detected for 15s => auto-pause (accountability).
      * If EAR below threshold for 10s => auto-pause (sleep detection).
  - Keep interaction with existing showFaceStatusPrompt/hideFaceStatusPrompt and pauseTimer(true)
  - Provide a small debug overlay controlled by localStorage key 'faceDebug' (set to '1' to see debug).
*/

// EAR threshold and timers
const EYE_AR_THRESH = 0.22; // tuned threshold for MediaPipe landmarks
const AWAY_PAUSE_MS = 15000; // 15 seconds
const EYE_CLOSED_PAUSE_MS = 10000; // 10 seconds

// Landmark indices for EAR (MediaPipe face mesh indices)
const LEFT_EYE_IDX = [33, 160, 158, 133, 153, 144];  // left eye landmarks
const RIGHT_EYE_IDX = [263, 387, 385, 362, 380, 373]; // right eye landmarks

// utility: euclidean distance
function dist(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    const dz = (a.z || 0) - (b.z || 0);
    return Math.sqrt(dx*dx + dy*dy + dz*dz);
}

// compute EAR using MediaPipe landmarks for one eye
function computeEARFromLandmarks(landmarks, idxArray) {
    // landmarks: array of {x,y,z}
    const p0 = landmarks[idxArray[0]];
    const p1 = landmarks[idxArray[1]];
    const p2 = landmarks[idxArray[2]];
    const p3 = landmarks[idxArray[3]];
    const p4 = landmarks[idxArray[4]];
    const p5 = landmarks[idxArray[5]];
    // A = dist(p1, p5), B = dist(p2, p4), C = dist(p0, p3)
    const A = dist(p1, p5);
    const B = dist(p2, p4);
    const C = dist(p0, p3);
    if (C === 0) return 1.0;
    return (A + B) / (2.0 * C);
}

// initialization of MediaPipe FaceMesh and Camera
async function initFaceMesh() {
    if (faceMesh) return;
    faceMesh = new FaceMesh({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
    }});
    faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });

    faceMesh.onResults(onFaceMeshResults);

    // Create camera helper
    camera = new Camera(DOMElements.video, {
        onFrame: async () => {
            await faceMesh.send({image: DOMElements.video});
        },
        width: 640,
        height: 480
    });
}

// starts the camera (prompts permission)
async function startVideo() {
    try {
        if (DOMElements.video.srcObject) return;
        // camera.start() will call getUserMedia internally via MediaPipe Camera util
        if (!faceMesh) await initFaceMesh();
        await camera.start();
        DOMElements.video.classList.remove('hidden');
    } catch (err) {
        alert("Camera access is required for Accountability features. Please allow access and refresh.");
        DOMElements.settings.accountabilityToggle.checked = false;
        DOMElements.settings.sleepDetectionToggle.checked = false;
        isAccountabilityOn = false;
        isSleepDetectionOn = false;
        window.isAccountabilityOn = isAccountabilityOn;
        window.isSleepDetectionOn = isSleepDetectionOn;
        saveSettingsToData();
    }
}

function stopVideo() {
    try {
        if (camera) {
            camera.stop();
        }
        // stop tracks if any (safe)
        if (DOMElements.video && DOMElements.video.srcObject) {
            DOMElements.video.srcObject.getTracks().forEach(t => t.stop());
            DOMElements.video.srcObject = null;
        }
        DOMElements.video.classList.add('hidden');
    } catch (e) {
        console.warn("Error stopping video:", e);
    }
}

// start detection loop
async function startFaceDetection() {
    if (faceDetectionRunning) return;
    // initialize face mesh if not already
    await initFaceMesh();
    faceDetectionRunning = true;
    awayTimerStart = null;
    eyesClosedTimerStart = null;
    lastFaceDetected = false;
    lastEAR = 1.0;
    // ensure camera / video started
    await startVideo();
}

// stop detection loop and cleanup
function stopFaceDetection() {
    faceDetectionRunning = false;
    awayTimerStart = null;
    eyesClosedTimerStart = null;
    lastFaceDetected = false;
    lastEAR = 1.0;
    hideFaceStatusPrompt();
    try { stopVideo(); } catch(e){ /* ignore */ }
}

// callback invoked by MediaPipe when new results are available
function onFaceMeshResults(results) {
    // results.multiFaceLandmarks is an array
    const multi = results.multiFaceLandmarks || [];
    const faceDetected = multi.length > 0;
    lastFaceDetected = faceDetected;

    // debug EAR
    let ear = 1.0;

    if (faceDetected) {
        const lm = multi[0]; // first face landmarks
        const leftEAR = computeEARFromLandmarks(lm, LEFT_EYE_IDX);
        const rightEAR = computeEARFromLandmarks(lm, RIGHT_EYE_IDX);
        ear = (leftEAR + rightEAR) / 2.0;
        lastEAR = ear;
    }

    // ACCOUNTABILITY: if enabled, check face presence
    if (isAccountabilityOn) {
        if (!faceDetected) {
            if (!awayTimerStart) {
                awayTimerStart = Date.now();
                showFaceStatusPrompt("Are you there? Timer will pause soon...");
            } else if (Date.now() - awayTimerStart > AWAY_PAUSE_MS) {
                pauseTimer(true);
                showFaceStatusPrompt("Timer paused. Come back to resume.");
            }
        } else {
            // face detected -> reset away timer
            if (awayTimerStart) {
                awayTimerStart = null;
                hideFaceStatusPrompt();
                // resume timer if it was auto-paused
                if (!isRunning && !pauseWasManual) startTimer(true);
            }
        }
    }

    // SLEEP DETECTION: if enabled, check EAR threshold
    if (isSleepDetectionOn && faceDetected) {
        if (ear < EYE_AR_THRESH) {
            if (!eyesClosedTimerStart) {
                eyesClosedTimerStart = Date.now();
                showFaceStatusPrompt("Feeling sleepy? Timer will pause.");
            } else if (Date.now() - eyesClosedTimerStart > EYE_CLOSED_PAUSE_MS) {
                pauseTimer(true);
                showFaceStatusPrompt("Timer paused due to inactivity.");
                playRandomSound('bad');
            }
        } else {
            if (eyesClosedTimerStart) {
                eyesClosedTimerStart = null;
                hideFaceStatusPrompt();
                if (!isRunning && !pauseWasManual) startTimer(true);
            }
        }
    } else if (isSleepDetectionOn && !faceDetected) {
        // if face not visible and sleep detection enabled, show a message
        showFaceStatusPrompt("Face not visible");
    }

    // optional debug overlay (off by default)
    const dbg = localStorage.getItem('faceDebug') === '1';
    showDebugOverlay(dbg, faceDetected, ear);
}

// small debug overlay rendering
function showDebugOverlay(enabled, faceDetected, ear) {
    let overlay = document.getElementById('__face_debug_overlay__');
    if (!overlay && enabled) {
        overlay = document.createElement('div');
        overlay.id = '__face_debug_overlay__';
        overlay.style.position = 'fixed';
        overlay.style.right = '12px';
        overlay.style.top = '12px';
        overlay.style.zIndex = '9999';
        overlay.style.background = 'rgba(0,0,0,0.6)';
        overlay.style.color = 'white';
        overlay.style.padding = '8px 10px';
        overlay.style.borderRadius = '8px';
        overlay.style.fontSize = '13px';
        document.body.appendChild(overlay);
    }
    if (overlay && enabled) {
        overlay.innerHTML = `<div><strong>Face:</strong> ${faceDetected ? 'Yes' : 'No'}</div>
                             <div><strong>EAR:</strong> ${ear.toFixed(3)}</div>
                             <div><small>AwayStart: ${awayTimerStart ? Math.round((Date.now()-awayTimerStart)/1000)+'s' : '-'}</small></div>
                             <div><small>EyesStart: ${eyesClosedTimerStart ? Math.round((Date.now()-eyesClosedTimerStart)/1000)+'s' : '-'}</small></div>`;
    } else if (overlay && !enabled) {
        overlay.remove();
    }
}

// ===================================================================================
// FACE PROMPT UI
// ===================================================================================
function showFaceStatusPrompt(message) {
    DOMElements.faceStatusPrompt.textContent = message;
    DOMElements.faceStatusPrompt.classList.add('visible');
}

function hideFaceStatusPrompt() {
    DOMElements.faceStatusPrompt.classList.remove('visible');
}

// ===================================================================================
// INITIALIZATION & UI LOGIC
// ===================================================================================
async function initializeAppState() {
    loadSettingsFromData();
    updateTimerDisplay();
    updateUIState();
    loadTodos();
    updateCornerWidget();
    DOMElements.profile.nameDisplay.textContent = currentUserData.profileName || "Floww User";
    loadTheme();
    // we don't auto-init MediaPipe here; it will be initialized on demand when toggles enable it
    // but we can pre-init if desired (commented)
    // await initFaceMesh();
}

function loadSettingsFromData() {
    const settings = currentUserData.settings || {};
    workDuration = settings.workDuration || 25 * 60;
    shortBreakDuration = settings.shortBreakDuration || 5 * 60;
    longBreakDuration = settings.longBreakDuration || 15 * 60;
    if (!isRunning && !isWorkSession) {
         timeLeft = (sessionCount % 4 === 0) ? longBreakDuration : shortBreakDuration;
    } else if (!isRunning) {
        timeLeft = workDuration;
    }

    document.getElementById('work-duration').value = workDuration / 60;
    document.getElementById('short-break-duration').value = shortBreakDuration / 60;
    document.getElementById('long-break-duration').value = longBreakDuration / 60;
    DOMElements.settings.soundEffects.value = settings.soundProfile || 'indian';
    DOMElements.settings.accountabilityToggle.checked = settings.isAccountabilityOn || false;
    DOMElements.settings.sleepDetectionToggle.checked = settings.isSleepDetectionOn || false;

    isAccountabilityOn = settings.isAccountabilityOn || false;
    isSleepDetectionOn = settings.isSleepDetectionOn || false;
    window.isAccountabilityOn = isAccountabilityOn;
    window.isSleepDetectionOn = isSleepDetectionOn;
}

function saveSettingsToData() {
    const newWork = parseInt(document.getElementById('work-duration').value, 10) * 60;
    const newShort = parseInt(document.getElementById('short-break-duration').value, 10) * 60;
    const newLong = parseInt(document.getElementById('long-break-duration').value, 10) * 60;

    if (newWork && newShort && newLong) {
        currentUserData.settings = currentUserData.settings || {};
        currentUserData.settings.workDuration = newWork;
        currentUserData.settings.shortBreakDuration = newShort;
        currentUserData.settings.longBreakDuration = newLong;
        currentUserData.settings.soundProfile = DOMElements.settings.soundEffects.value;
        currentUserData.settings.isAccountabilityOn = DOMElements.settings.accountabilityToggle.checked;
        currentUserData.settings.isSleepDetectionOn = DOMElements.settings.sleepDetectionToggle.checked;

        isAccountabilityOn = DOMElements.settings.accountabilityToggle.checked;
        isSleepDetectionOn = DOMElements.settings.sleepDetectionToggle.checked;
        window.isAccountabilityOn = isAccountabilityOn;
        window.isSleepDetectionOn = isSleepDetectionOn;

        saveUserData();
        loadSettingsFromData();
        if (!isRunning) resetTimer();
        alert("Settings saved!");
    } else {
        alert("Please enter valid numbers for all durations.");
    }
}

function showCompletionPopup() { DOMElements.modals.completion.classList.add('visible'); }
function openStats() { DOMElements.modals.stats.classList.add('visible'); renderCharts(); updateStatsDisplay(); }
function closeStats() { DOMElements.modals.stats.classList.remove('visible'); }
function updateStatsDisplay() {
    const totalMinutes = currentUserData.totalFocusMinutes || 0;
    DOMElements.modals.totalFocusTime.textContent = `${Math.floor(totalMinutes / 60)}h ${totalMinutes % 60}m`;
    DOMElements.modals.totalSessionsCount.textContent = currentUserData.totalSessions || 0;
}
function showSessionReview() {
    if (!sessionStartTime || !isWorkSession) return;
    const totalDurationMs = Date.now() - sessionStartTime;
    const currentPauseDuration = lastPauseTimestamp ? Date.now() - lastPauseTimestamp : 0;
    const awayTimeMs = totalAwayTime + currentPauseDuration;
    const focusTimeMs = totalDurationMs - awayTimeMs;
    const formatMs = (ms) => {
        const totalSeconds = Math.max(0, Math.floor(ms / 1000));
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}m ${seconds}s`;
    };

    document.getElementById('reviewFocusTime').textContent = formatMs(focusTimeMs);
    document.getElementById('reviewAwayTime').textContent = formatMs(awayTimeMs);
    document.getElementById('reviewTotalDuration').textContent = formatMs(totalDurationMs);
    DOMElements.modals.review.classList.add('visible');
}

function loadTodos() {
    const todos = currentUserData.todos || [];
    const todoList = document.getElementById('todo-list');
    todoList.innerHTML = '';
    todos.forEach((todo, index) => {
        const li = document.createElement('li');
        li.className = 'todo-item';
        li.innerHTML = `<input type="checkbox" id="todo-${index}" ${todo.completed ? 'checked' : ''}> <label for="todo-${index}">${todo.text}</label>`;
        li.querySelector('input').onchange = () => toggleTodo(index);
        todoList.appendChild(li);
    });
}
function addTodo() { const input = document.getElementById('todo-input'); if (input.value.trim()) { if (!currentUserData.todos) currentUserData.todos = []; currentUserData.todos.push({ text: input.value.trim(), completed: false }); saveUserData(); input.value = ''; loadTodos(); } }
function toggleTodo(index) { if (currentUserData.todos[index]) { currentUserData.todos[index].completed = !currentUserData.todos[index].completed; saveUserData(); loadTodos(); } }
function clearTodos() { if (confirm("Clear all tasks?")) { currentUserData.todos = []; saveUserData(); loadTodos(); } }

function updateCornerWidget() {
    const now = new Date();
    const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const dayProgress = ((now - startOfDay) / 86400000) * 100;
    document.getElementById("dayProgressBar").style.width = `${dayProgress}%`;
    document.getElementById("dayProgressPercent").textContent = `${Math.floor(dayProgress)}%`;
    const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
    const monthProgress = (now.getDate() / endOfMonth.getDate()) * 100;
    document.getElementById("monthProgressBar").style.width = `${monthProgress}%`;
    document.getElementById("monthProgressPercent").textContent = `${Math.floor(monthProgress)}%`;
    const startOfYear = new Date(now.getFullYear(), 0, 1);
    const isLeap = new Date(now.getFullYear(), 1, 29).getMonth() === 1;
    const totalDaysInYear = isLeap ? 366 : 365;
    const dayOfYear = Math.floor((now - startOfYear) / 86400000) + 1;
    const yearProgress = (dayOfYear / totalDaysInYear) * 100;
    document.getElementById("yearProgressBar").style.width = `${yearProgress}%`;
    document.getElementById("yearProgressPercent").textContent = `${Math.floor(yearProgress)}%`;
}

function toggleFocusMode() { document.body.classList.toggle('focus-mode'); }

function ambientLoop(timestamp) {
    if (isSnowActive && timestamp - lastSnowSpawn > SNOW_INTERVAL) { lastSnowSpawn = timestamp; createAndAnimateElement('snowflake', 8, 15, 'fall'); }
    if (isRainActive && timestamp - lastRainSpawn > RAIN_INTERVAL) { lastRainSpawn = timestamp; createAndAnimateElement('raindrop', 0.4, 0.8, 'fall'); }
    if (isSakuraActive && timestamp - lastSakuraSpawn > SAKURA_INTERVAL) { lastSakuraSpawn = timestamp; createAndAnimateElement('sakura', 15, 25, 'spinFall'); }
    if (isSnowActive || isRainActive || isSakuraActive) { animationFrameId = requestAnimationFrame(ambientLoop); } else { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
}
function createAndAnimateElement(className, minDuration, maxDuration, animationName) {
    const el = document.createElement('div');
    el.className = `ambient-effect ${className}`;
    el.style.left = `${Math.random() * 100}vw`;
    el.style.animation = `${animationName} ${Math.random() * (maxDuration - minDuration) + minDuration}s linear forwards`;
    DOMElements.ambientContainer.appendChild(el);
    el.addEventListener('animationend', () => el.remove());
}
function toggleAmbience(type) {
    if (type === 'snow') isSnowActive = !isSnowActive;
    if (type === 'rain') isRainActive = !isRainActive;
    if (type === 'sakura') isSakuraActive = !isSakuraActive;
    document.getElementById(`${type}Btn`).classList.toggle('active');
    if (!animationFrameId && (isSnowActive || isRainActive || isSakuraActive)) {
        animationFrameId = requestAnimationFrame(ambientLoop);
    }
}

function getYoutubeVideoId(url) {
    const m = url.match(/(?:[?&]v=|\/embed\/|youtu\.be\/)([^"&?/\s]{11})/);
    return m ? m[1] : null;
}
function setYoutubeBackground(videoId) { document.getElementById("video-background-container").innerHTML = `<iframe src="https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&loop=1&playlist=${videoId}&controls=0&modestbranding=1&rel=0&showinfo=0&iv_load_policy=3" frameborder="0" allow="autoplay"></iframe>`; document.body.style.backgroundImage = 'none'; }
function applyBackgroundTheme(path) { document.body.style.backgroundImage = `url('${path}')`; document.getElementById("video-background-container").innerHTML = ''; }
function loadTheme() { if (currentUserData.theme?.backgroundPath) applyBackgroundTheme(currentUserData.theme.backgroundPath); if (currentUserData.theme?.youtubeVideoId) setYoutubeBackground(currentUserData.theme.youtubeVideoId); }

// ===================================================================================
// EVENT LISTENERS ATTACH (partial listing here; please ensure your original event attachments remain intact in your copy)
// ===================================================================================
function attachMainAppEventListeners() {
    DOMElements.playPauseBtn.addEventListener('click', () => isRunning ? pauseTimer() : startTimer(true));
    DOMElements.resetBtn.addEventListener('click', resetTimer);
    DOMElements.endSessionBtn.addEventListener('click', endSession);
    document.getElementById('changeNameBtn').addEventListener('click', () => { const newName = prompt("Enter new name:", currentUserData.profileName); if (newName && newName.trim()) { currentUserData.profileName = newName.trim(); saveUserData(); DOMElements.profile.nameDisplay.textContent = newName.trim(); } });
    // Note: other event listeners (stats, settings save, etc.) should be attached similarly in your other code below
}

// ===================================================================================
// On page load: attach listeners and initialize basic UI wiring
// ===================================================================================
document.addEventListener('DOMContentLoaded', () => {
    // Attach your other listeners (login/signup, settings, todo buttons etc.)
    attachMainAppEventListeners();

    // settings save button
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');
    if (saveSettingsBtn) saveSettingsBtn.addEventListener('click', saveSettingsToData);

    // attach accountability toggle change to immediately enable/disable detection
    const accToggle = document.getElementById('accountability-toggle');
    const sleepToggle = document.getElementById('sleep-detection-toggle');
    if (accToggle) accToggle.addEventListener('change', (e) => {
        isAccountabilityOn = e.target.checked;
        window.isAccountabilityOn = isAccountabilityOn;
        currentUserData.settings = currentUserData.settings || {};
        currentUserData.settings.isAccountabilityOn = isAccountabilityOn;
        saveUserData();
        if (isAccountabilityOn || isSleepDetectionOn) {
            startFaceDetection();
        } else {
            stopFaceDetection();
        }
    });
    if (sleepToggle) sleepToggle.addEventListener('change', (e) => {
        isSleepDetectionOn = e.target.checked;
        window.isSleepDetectionOn = isSleepDetectionOn;
        currentUserData.settings = currentUserData.settings || {};
        currentUserData.settings.isSleepDetectionOn = isSleepDetectionOn;
        saveUserData();
        if (isAccountabilityOn || isSleepDetectionOn) {
            startFaceDetection();
        } else {
            stopFaceDetection();
        }
    });

    // close review modal
    const closeReviewModalBtn = document.getElementById('closeReviewModalBtn');
    if (closeReviewModalBtn) closeReviewModalBtn.addEventListener('click', () => {
        DOMElements.modals.review.classList.remove('visible');
    });

    // basic start: initialize UI state if user is already signed-in in onAuthStateChanged handler
});

// ===================================================================================
// End of file - rest of your original functions and code should remain exactly as before.
// If you have more event binding or functions at bottom of your original script, ensure they are present as in your repository.
// ===================================================================================
